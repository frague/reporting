#!/usr/bin/python

import libxml2
from rabbithole import *

'''

<td>activemq.queue</td>
                <td colspan=2>Consumer.TORS.VirtualTopic.ODB_ALL</td>


<td>activemq.queue</td>
                <td colspan=2>Consumer.TORS_a04.VirtualTopic.ODB_ALL</td>


'''

'''
<p><b>Version</b><br/>
            0.3.2</p>

'''


ProfileNeeded()

stats = {}
queueExpr = re.compile("<td>activemq.queue</td>[^<]*<td[^>]*>([^<]*)</td>", re.MULTILINE)
versionExpr = re.compile("<p><b>Version</b><br/>([^<]+)</p>", re.MULTILINE)
stateExpr = re.compile("<p><b>System State</b><br/>([^<]+)</p>", re.MULTILINE)
zoneExpr = re.compile("<td>rules.placeholder.zone</td>[^<]*<td[^>]*>([^<]*)</td>", re.MULTILINE)
haExpr = re.compile("CassandraStatus: ([A-Z]+)")


template = GetTemplate("queues_main")
setTemplate = GetTemplate("queues_set")
lineTemplate = GetTemplate("queues_line")
hostTemplate = GetTemplate("queues_host")
emptyTemplate = GetTemplate("queues_empty")

na = "_N/A_"
used = {}

def GetDeployedQueue(url):
	global used, na

	match = None
	version = na
	state = na
	zone = na
	ha = na
	
	try:
		page = GetWebPage(url)
		
		version = GetMatchGroup(page, versionExpr, 1, na).strip()
		state = GetMatchGroup(page, stateExpr, 1, na).strip()
		zone = GetMatchGroup(page, zoneExpr, 1, na)
		ha = GetMatchGroup(page, haExpr, 1, na)
		if ha == "CONNECTED":
			ha = "Cluster"
		else:
			ha = "Single"

		match = queueExpr.search(page)
	except:
		return {"queue": "_N/A_", "version": version, "state": state, "zone": zone, "ha": ha}

	if match:
		key = match.group(1)
		if used.has_key(key):
			key = "{color:red}%s{color}" % key
		used[key] = True
		return {"queue": key, "version": version, "state": state, "zone": zone, "ha": ha}

	return {"queue": "", "version": version, "state": state, "zone": zone, "ha": ha}

print "--- Check if connected..."
try:
	GetWebPage(config["check_connection_url"])
except:
	print "[!] Not connected to VPN!"
	exit(0)

#############################################################################################################
## Getting queues consumers

url = GetParameter("url") or config["queues"]
if not url:
	print "[!] URL is not provided. Usage: queues.py --profile=<Profile> --url=<Queues Page URL>"
	exit(0)

keepTrying = True
while keepTrying:
	try:
		subscribers = ""
		doc = libxml2.parseDoc(WgetPage(url))
		queues = [q.prop("name") for q in doc.xpathNewContext().xpathEval("//queue/stats[@consumerCount='0']/parent::*")]
		ours = re.compile("(tors|ras|cloud)", re.IGNORECASE)

		for q in queues:
			if ours.search(q):
				q = "{color:red}%s{color}" % q
			if subscribers:
				subscribers += ", "
			subscribers += q
		keepTrying = False
	except:
		print "[!] Error parsing queues. Re-attempting in 5 seconds."
		time.sleep(5)

## Getting deployed versions

ports = ["", ":8080"]
contexts = ["ras", "ebcloud"]

queues = ""
for set in sorted(config["deployments"].keys()):
	print "--- %s" % set
	result = []
	for env in sorted(config["deployments"][set].keys()):
		rows = 0
		sub_result = []
		for port in ports:
			for context in contexts:
				url = "http://%s%s/%s/info" % (config["deployments"][set][env], port, context)

				parsed = GetDeployedQueue(url)
				if parsed["version"] != na:
					print "  * %s %s (ver. %s) uses queue %s" % (env, url, parsed["version"], parsed["queue"])

					t = lineTemplate
					if rows:
						t = hostTemplate

					sub_result.append(FillTemplate(t, {"##TITLE##": env, "##URL##": url, "##COMMENT##": parsed["queue"], "##VERSION##": parsed["version"], "##STATE##": parsed["state"], "##ZONE##": parsed["zone"], "##HA##": parsed["ha"]}))
					rows += 1

		if rows == 0:
			sub_result = [FillTemplate(emptyTemplate, {"##TITLE##": env, "##URL##": config["deployments"][set][env]})]
		else:
			sub_result[0] = sub_result[0].replace("##ROWS##", str(rows))

		result += sub_result

	queues += FillTemplate(setTemplate, {"##TITLE##": set, "##INSTANCES##": "".join(result)}) + "\n";

print "--- Publishing to wiki"

wikiServer = xmlrpclib.ServerProxy(config["wiki_xmlrpc"])
wikiToken = wikiServer.confluence1.login(config["wiki"]["user"], config["wiki"]["password"])

page = wikiServer.confluence1.getPage(wikiToken, config["project_space"], "ActiveMQ queues utilization (autogenerated)")
page["content"] = FillTemplate(template, {"##CONSUMERS##": subscribers, "##QUEUES##": queues, "##UPDATED##": datetime.datetime.today().strftime("%b %d, %Y (%H:%M)")})
wikiServer.confluence1.updatePage(wikiToken, page, {"minorEdit": True})

print "Done."
